#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     color,          sensorCOLORFULL)
#pragma config(Sensor, S3,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     slide,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     tail,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftWheel,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rightWheel,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     block,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"	// just files to make the SMUX work.
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/lego-ultrasound.h"
#include "JoystickDriver.c"								// for the waitForStart() command.

const tMUXSensor irLeft = msensor_S4_3;		// configuring the IR and sonar sensor over the SMUX.
const tMUXSensor irRight = msensor_S4_2;
const tMUXSensor sonarLeft = msensor_S4_4;
const tMUXSensor sonarRight = msensor_S4_1;


float strengthLeft(){
	int ac1,ac2,ac3,ac4,ac5 = 0;			// reading of all sensors to compute "strength"
	float s;											  	// strenght value

	HTIRS2readAllACStrength(irLeft, ac1, ac2, ac3, ac4, ac5 ); // reading the strength of all the sensors of the left beacon
	s = ac1+ac2+ac3+ac4+ac5;

	return(s);												// return the strength
}


float strengthRight(){
	int ac1,ac2,ac3,ac4,ac5 = 0;			// reading of all sensors to compute "strength"
	float s;

	HTIRS2readAllACStrength(irRight, ac1, ac2, ac3, ac4, ac5 ); // reading the strength of all the sensors of the left beacon
	s = ac1+ac2+ac3+ac4+ac5;

	return(s);
}


void findIR() // program to go to the IR beacon and drop the block.
{
	int leftWheelPwr = 0;
	int rightWheelPwr = 0;
	float sL, sR;											  // strenght left and right


	motor[leftWheel] = 30;						// move forward
	motor[rightWheel] = 30;


	sL = strengthLeft();
	sR = strengthRight();

	while(sL/sR<2.0 && sL/sR>0.5 ){			// if the strength are within a factor of 2 of each other
		sL = strengthLeft();
		sR = strengthRight();
	}

	if(sL>sR)					// see which side the IR is...
	{									// it is on the left!
		while(HTIRS2readACDir(irLeft) != 5) // while we're not in front of the beacon.
		{
			sL = USreadDist(sonarLeft);
			if(sL<50){
				motor[leftWheel]  = 30+ 0.5*(20-sL) ;		// try to keep 20cm distance
				motor[rightWheel] = 30- 0.5*(20-sL) ;
			}
		}
		// we should now be in front of the beacon and the beacon is on the left

		// turn left
		// drop block
		// turn right ... not exactly...  just undo the turn left above...
		// back up keeping 20 cm on the left
		// until the left sonar goes to a high value... say >50
		// then turn left
		// move forward until line
		// turn right
		// move forward go up the ramp...

	}
	else	// the beacon is on the right
	{
		while(HTIRS2readACDir(irRight) != 5) // while we're not in front of the beacon.
		{
			sR = USreadDist(sonarRight);
			if(sR<50){
				motor[leftWheel]  = 30- 0.5*(20-sL) ;
				motor[rightWheel] = 30+ 0.5*(20-sL) ;
			}
		}

		// turn right
		// drop block
		// turn left
		// back up keeping 20 cm on the right
		// until the right sonar goes to a high value... say >50
		// then turn right
		// move forward until line
		// turn left
		// move forward go up the ramp...

	}

	//we are done...

}


task main()
{



}
