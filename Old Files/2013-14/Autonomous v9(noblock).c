#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     controller,     sensorI2CMuxController)
#pragma config(Sensor, S2,     color,          sensorCOLORFULL)
#pragma config(Sensor, S3,     blockSonar,     sensorSONAR)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustom)
#pragma config(Motor,  motorA,          leftPick,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightPick,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     leftWheel,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightWheel,    tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    topLeft,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    bottomLeft,           tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    tail,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_1,    topRight,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    bottomRight,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"  // just files to make the SMUX work.
#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"

const tMUXSensor irLeft = msensor_S4_1; 	// configuring the IR sensor over the SMUX.
const tMUXSensor irRight = msensor_S4_2;

int lhist[200],rhist[200],nsteps,dt;			// used to keep the history of commands
int totrot = 0;														// total accumulated rotation

// These are some standard positions for the arm

void home()														  // home position - initial and driving position
{
	servo[bottomLeft] = 64-5;
	servo[bottomRight] = 64+5;
	servo[topLeft] = 64-11;
	servo[topRight] =64+11;
}

void drop(){														// drop arm position - when ready to drop block
	servo[bottomLeft] = 64-5;
	servo[bottomRight] = 64+5;
	servo[topLeft] = 64-2;
	servo[topRight] = 64+2;
}

void inter(){										   		//intermediate position to go from pick to home

	servo[bottomLeft] = 64-8;
	servo[bottomRight] = 64+8;
	servo[topLeft] = 64-8;
	servo[topRight] = 64+8;
}

void spit()														// spit the block out
{
	motor[leftPick] = 100;
	motor[rightPick] = 100;
	wait10Msec(100);
	motor[leftPick] = 0;
	motor[rightPick] = 0;
}


void pick()
{													 // pick up block - arm position
	servo[bottomLeft] = 64-3;
	servo[bottomRight] = 64+3;
	servo[topLeft] = 64-8;
	servo[topRight] = 64+8 ;

	motor[leftPick] = 100;
	motor[rightPick] = 100;

	int threshold = 10;

	while(SensorValue(blockSonar)>=threshold){
		motor[leftPick]=-30;
		motor[rightPick]=-30;
		//nxtDisplayString(1,"%5d",SensorValue(blockSonar));
	}

	motor[leftPick]=0;
	motor[rightPick]=0;
}


void seek_beacon(){									 //search for IR beacon and stop in front of it...

	int leftReading=0;								// reading of IR position on left eye
	int rightReading=0;								// reading of IR position on right eye
	int t,r,acc = 0;
	int ac1,ac2,ac3,ac4,ac5 = 0;			// reading of all sensors to compute "strength"
	int strength,speed=0;							// the strength of the IR beacon and the speed of the robot
	int flag = 0;											// will be 1 when the IR beacon is found
	int t0;														// initial time

	nsteps=0;													// number of steps taken

	t0 = nPgmTime;

	while(!flag)
	{

		HTIRS2readAllACStrength(irLeft, ac1, ac2, ac3, ac4, ac5 ); // reading the strength of all the sensors of the left beacon
		acc = ac1+ac2+ac3+ac4+ac5;
		HTIRS2readAllACStrength(irRight, ac1, ac2, ac3, ac4, ac5 ); // reading the strength of all the sensors of the right beacon
		acc = acc+ac1+ac2+ac3+ac4+ac5;

		strength = 0.75*strength+0.25*acc; 						// compute strength and smooth the strength over time

		if(strength<200)										// if stregnth is small we are far away and move fast
			speed = 0.8*speed+0.2*35;
		else																// when we get closer we move slower and we also smooth speed over time
			speed = 0.8*speed+0.2*15;

		// CALIBRATE -- (6,4) are the target values for the distance, but it may need to be calibrated in the real field.

		leftReading  = HTIRS2readACDir(irLeft)  -6;		// compute error for left and right eyes
		rightReading = HTIRS2readACDir(irRight) -4;

		// compute transatino and rotation component of the movement depending on the errors

		t = -sgn(leftReading-rightReading);
		r =  sgn(leftReading+rightReading);

		// we will accumulate the rotation so we know at the end if we rotated left or right to reach the beacon

		totrot += r*t;

		if(leftReading == 0 && rightReading == 0){		//if the errors are zero we reached the target

			motor[leftWheel] = 0;												//and we stop the motors and exit
			motor[rightWheel] = 0;
			flag = 1;

			} else {														// we are still searching

			lhist[nsteps] = speed*(t-0.6*r);		// keep a history of our movements commands
			rhist[nsteps] = speed*(t+0.6*r);

			motor[leftWheel]  = lhist[nsteps];	// set the new commands
			motor[rightWheel] = rhist[nsteps];

			nsteps++;														// keep the number of commands steps...
		}
	}

	t0 = nPgmTime-t0;												// how long we needed to get to the target
	dt = t0/nsteps;													// calculate average delay between commands

}

void gobackhome(){ 												// returns to start position by playing back the history of motor commands

	while(--nsteps>=0){											// play back history in reverse
		motor[rightWheel] = -rhist[nsteps];
		motor[leftWheel] = -lhist[nsteps];
		wait1Msec(dt);
	}

	motor[rightWheel] = 0;									// stop motors
	motor[leftWheel] = 0;
}


void lookforline(){												// looks for the white line

	short nRawValues[4];
	float tmp;

	tmp = 0;
	motor[leftWheel] = 10;									// move forward
	motor[rightWheel] = 10;

	while(tmp<3.5){													// keep moving until we find the line...
		getColorSensorData(color, colorAtoD,&nRawValues[0]);
		tmp = (float)(nRawValues[0]+nRawValues[1]+nRawValues[2])/(3.0*nRawValues[3]);
	}

	motor[leftWheel] = 0;										// stop
	motor[rightWheel] = 0;

}

void turnleft(float x){										//turns x degrees left - CALIBRATE
	motor[leftWheel] = 8;
	motor[rightWheel] = -8;
	wait10Msec(205*x/90.0);
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void turnright(float x){									//turns x degress right - CALIBRATE
	motor[leftWheel] = -8;
	motor[rightWheel] = 8;
	wait10Msec(205*x/90.0);
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}



	task main()
	{

		bSystemLeaveServosEnabledOnProgramStop=true;  // leaves power on so we are in home position after autonomous period, and so that the robot doesn't just fall down.

		home();
		servo[tail] = 127;	// stop tail just in case....
		wait10Msec(100);		// wait a bit...

		waitForStart(); 		// Wait for the beginning of autonomous phase.
/*
		drop();							// Bring arm into drop position

		motor[leftWheel] = 30;
		motor[rightWheel] = 30 ;
		wait1Msec(650); //was 500, 1000 doesn't work, 750 is too high

		seek_beacon();			//find IR beam

		spit();					  	//spit the cube (into the basket please...)

		gobackhome();				//trace back your steps

		home();							//get arm to home position
*/
		wait1Msec(35);			//wait a bit... before turning

		if(totrot<0)				// turn 90 depending where we come from
			turnleft(130.0);		// CALIBRATE!!!
		else
			turnright(130.0);

		lookforline();			// look for white line

		if(totrot<0)				// turn 90 to go up the ramp... CALIBRATE!
			turnright(130.0);
		else
			turnleft(130.0);

		motor[leftWheel] = 25;	// go up the ramp
		motor[rightWheel] = 25;

		wait10Msec(275); 				//CALIBRATE time to make sure we get on the ramp

		motor[leftWheel] = 0;		// stop motor
		motor[rightWheel] = 0;

		// done! ...  How did I do?

	}
