#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     controller,     sensorNone)
#pragma config(Sensor, S2,     color,          sensorCOLORFULL)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     leftMotor,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rightMotor,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_1,    servo7,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"  // just files to make the SMUX work.
#include "drivers/hitechnic-irseeker-v2.h"
#include "JoystickDriver.c"               // the files for the Logitech controller to work by USB to the laptop and then by bluetooth/USB to the NXT, NOT by samantha module.

#define DEBUG														// used only for debugging... delete when trying the program for real.
#define NODATA 12345					          // special number to indicate NO DATA from sensor
#define LEFT_TARGET 100
#define RIGHT_TARGET 80

const tMUXSensor irLeft = msensor_S4_1; // configuring the IR sensor over the SMUX.
const tMUXSensor irRight = msensor_S4_2;

int boundCommand(int com){ 										// making sure motors don't get commands that arent in between the -100 - 100 range.
return( (abs(com)>100) ? sgn(com)*100 : com);
}

int rotation(int leftErr, int rightErr) { // calculating the rotation needed to get to the IR beacon.
	if ((abs (leftErr) <= 5 && abs (rightErr) <= 5)) return(0);  // if in goal don't turn
		int rot = leftErr + rightErr;
	rot = boundCommand(rot);
	return(rot);
}

int translation (int leftErr, int rightErr) { // calulating the translation needed to get to the IR beacon.

	if ((leftErr < 0 && rightErr < 0) || (leftErr > 0 && rightErr > 0) || (abs (leftErr) <= 5 && abs (rightErr) <= 5)) return(0); // no translation if in quadrants II or III or in goal.
		int trans = rightErr-leftErr;
	trans = boundCommand(trans);
	return (trans);


}

int IRseek(int leftErr, int rightErr) { // actual translation and rotation commands for the motors
	int leftCommand, rightCommand, trans, rot;

	if ((abs (leftErr) <= 5 && abs (rightErr) <= 5)) {          // if in target area => return 1 which is that we're there.
		motor[leftMotor] = 0;
		motor[rightMotor] = 0;
		return(1);
	}

	if (leftErr == NODATA && rightErr == NODATA)
	{
		motor[leftMotor] = 75;
		motor[rightMotor] = -75;
		return 0;
	}

	if (leftErr == NODATA) {
		motor[leftMotor] = 75;
		motor[rightMotor] = -75;
		return 0;
	}
	if (rightErr == NODATA)
	{
		motor[leftMotor] = -75;
		motor[rightMotor] = 75;
		return 0;
	}

	trans = translation (leftErr, rightErr);
	rot = rotation (leftErr, rightErr);
	leftCommand = trans + rot;
	rightCommand = trans - rot;
	leftCommand = boundCommand(leftCommand);
	rightCommand = boundCommand(rightCommand);
	motor[leftMotor] = leftCommand;
	motor[rightMotor] = rightCommand;

	return 0;                                    // we still haven't finished.
}

void dropBlock() {		// called after seekBeackon to drop the block...

}

void driver() {					// the driver controlled program, which is also for the endgame.
	int leftStick = joystick.joy1_y1;    // giving easier names to the two joysticks that are used for the wheels.
	int rightStick = joystick.joy1_y1;

	while(true) {
		getJoystickSettings(joystick);  // updating the joystick controller and the buttons.
		motor[leftMotor] = leftStick;
		motor[rightMotor] = rightStick;
	}

}


void displayText(int nLineNumber, const string cChar, int nValueAC)
{
	string sTemp,sTemp2;

	StringFormat(sTemp, "%4d ", nValueAC);
	StringFormat(sTemp2, "%s:  %s", cChar, sTemp);
	nxtDisplayTextLine(nLineNumber, sTemp2);
}

int readLeft() {

	int dirAC = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	// read the current modulated signal direction
	dirAC = HTIRS2readACDir(irLeft);
	if (dirAC < 0)
		return NODATA;

	// Read the individual signal strengths of the internal sensors
	// Do this for both unmodulated (DC) and modulated signals (AC)

	if (!HTIRS2readAllACStrength(irLeft, acS1, acS2, acS3, acS4, acS5 ))
		return NODATA; // I2C read error occurred

	displayText(1, "D", dirAC);
	displayText(2, "0", acS1);
	displayText(3, "1", acS2);
	displayText(4, "2", acS3);
	displayText(5, "3", acS4);
	displayText(6, "4", acS5);

	return dirAC;
}


int readRight() {

	int dirAC = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	// read the current modulated signal direction
	dirAC = HTIRS2readACDir(irRight);
	if (dirAC < 0)
		return NODATA;

	// Read the individual signal strengths of the internal sensors
	// Do this for both unmodulated (DC) and modulated signals (AC)

	if (!HTIRS2readAllACStrength(irRight, acS1, acS2, acS3, acS4, acS5 ))
		return NODATA; // I2C read error occurred

	displayText(1, "D", dirAC);
	displayText(2, "0", acS1);
	displayText(3, "1", acS2);
	displayText(4, "2", acS3);
	displayText(5, "3", acS4);
	displayText(6, "4", acS5);

	return dirAC;
}


void autonomous_mode(){

	int leftErr, rightErr;
	int leftSensor, rightSensor;

	leftSensor = readLeft();
	rightSensor = readRight();

	if(leftSensor == NODATA)
		leftErr = NODATA;
	else
		leftErr = leftSensor - LEFT_TARGET;

	if(rightSensor == NODATA)
		rightErr = NODATA;
	else
		rightErr = rightSensor - RIGHT_TARGET;

	while(!IRseek(leftErr,rightErr)){
		leftSensor = readLeft();
		rightSensor = readRight();

		if(leftSensor == NODATA)
			leftErr = NODATA;
		else
			leftErr = leftSensor - LEFT_TARGET;

		if(rightSensor == NODATA)
			rightErr = NODATA;
		else
			rightErr = rightSensor - RIGHT_TARGET;
	}

	// now it is time to drop the block

	dropBlock();
//	findLine();																// add later
//	climbRamp();
}

task main()
{

	while(1) readLeft();                     // just for calibration.

}
